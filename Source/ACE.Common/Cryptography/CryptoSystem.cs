using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ACE.Common.Cryptography
{
    /// <summary>
    /// Forward looking cache for ISAAC calculations.<para />
    /// Manages ISAAC stream cipher and key searches.<para />
    /// Manages a range of encryption keys generated by the stream cipher.<para />
    /// TO-DO: perhaps the search range dimensions can be tightened up or even made dynamic?
    /// </summary>
    public class CryptoSystem
    {
        /// <summary>
        /// the search limit of the distance from the left side to the center of the range of offsets<para />
        /// packet [corruption, dropped, out of order] are factors that should be considered<para />
        /// left <-> offset <-> right<para />
        /// </summary>
        private const int Left = 30;
        /// <summary>
        /// the search limit of the distance from the right side to the center of the range of offsets<para />
        /// packet [corruption, dropped, out of order] are factors that should be considered<para />
        /// left <-> offset <-> right<para />
        /// </summary>
        private const int Right = 30;
        /// <summary>
        /// The "middle" offset of the search-range.<para />
        /// </summary>
        private int offset = 0;
        /// <summary>
        /// The underlying stream cipher
        /// </summary>
        private ISAAC Wheel = null;
        /// <summary>
        /// The number of times the stream cipher has advanced.
        /// </summary>
        private int InternalOffset => Wheel.OverallOffset;
        /// <summary>
        /// leftmost and rightmost boundaries of the search-range
        /// </summary>
        private Tuple<int, int> SearchRange => new Tuple<int, int>(Math.Max(0, offset - Left), offset + Right);

        /// <summary>
        /// perhaps something like this would be better suited:<para />
        /// https://www.geeksforgeeks.org/interval-tree/
        /// </summary>
        private SortedDictionary<int, uint> Cache = new SortedDictionary<int, uint>();

        public CryptoSystem(byte[] seed)
        {
            if (seed == null)
            {
                throw new ArgumentNullException("seed can not be null");
            }
            if (seed.Length != 4)
            {
                throw new ArgumentOutOfRangeException("seed length is wrong");
            }
            Wheel = new ISAAC(seed);
        }

        /// <summary>
        /// the tuple validity test Tuple.ItemX == 0 won't work for CryptoSystem
        /// the non nullable needs a sibling for tracking its validity
        /// </summary>
        private struct CacheResult
        {
            public bool Invalid;
            public Tuple<int, uint> Key;
        }

        /// <summary>
        /// attempt to get a key identified by an offset<para />
        /// 1. if the key has never been generated yet then generate and store it<para />
        /// 2. return the cached key if it is present in the cache, or an invalid key if not
        /// </summary>
        /// <param name="offset">the offset of the requested key</param>
        /// <returns>the requested key or an invalid key in the case that the key identified by the offset was already generated and removed</returns>
        private CacheResult this[int offset]
        {
            get
            {
                uint? added = null;
                while (InternalOffset < offset + 1)
                {
                    added = Wheel.GetOffset();
                    Cache.Add(InternalOffset - 1, added.Value);
                }
                if (added != null)
                {
                    return new CacheResult() { Key = new Tuple<int, uint>(InternalOffset - 1, added.Value) };
                }
                if (!Cache.ContainsKey(offset))
                {
                    // the key was removed
                    return new CacheResult() { Invalid = true };
                }
                return new CacheResult() { Key = new Tuple<int, uint>(offset, Cache[offset]) };
            }
        }

        /// <summary>
        /// remove all disabled keys, keys having an offset prior to the current search-range<para />
        /// all keys left behind by the moving search-range will never be used for anything
        /// </summary>
        /// <returns>the number of removed keys</returns>
        private int RemoveDisabledKeys()
        {
            Tuple<int, int> range = SearchRange;
            List<int> toBeRelieved = Cache.Keys.Where(k => k < range.Item1).ToList();
            foreach (int offset in toBeRelieved)
            {
                Cache.Remove(offset);
            }
            return toBeRelieved.Count;
        }

        /// <summary>
        /// Except for retransmissions no key is ever used for encryption twice by the client, 
        /// Since the callback verified the key and packet validity we won't need to request retransmission
        /// Therefore we can safely discard the verified key
        /// </summary>
        /// <param name="offset">the verified key offset</param>
        /// <returns></returns>
        private bool RemoveVerifiedKey(int offset)
        {
            return Cache.Remove(offset);
        }

        /// <summary>
        /// move the search-range forward by 1
        /// </summary>
        public void RangeAdvance()
        {
            RangeAdvance(offset + 1);
        }

        /// <summary>
        /// set the center of the search-range to the specified offset
        /// </summary>
        /// <param name="offset"></param>
        public void RangeAdvance(int offset)
        {
            this.offset = offset;
            RemoveDisabledKeys();
        }

        /// <summary>
        /// enumerate through the current range of keys until the callback verifies a key or there are no more keys
        /// if the callback fails then either the key used to encrypt the CRC is not inside the range or the data was corrupted in transit
        /// </summary>
        /// <param name="callback">the verification callback</param>
        /// <param name="rangeAdvance">whether or not to set the current center-of-range offset to the verified offset and remove keys that are surpassed by the new range,
        /// Do NOT range advance for { [this]->reordering->processing } stage because it could allow walking the current range out of sync with the ordered packet stream.
        /// If the range is advanced beyond the (shared between client and server) stream position the session is destroyed.</param>
        /// <returns>whether the key offset was found or not, as reported by the callback testing each</returns>
        public bool Search(Func<Tuple<int, uint>, bool> callback, bool rangeAdvance)
        {
            Tuple<int, int> range = SearchRange;
            for (int i = range.Item1; i < range.Item2 + 1; i++)
            {
                CacheResult result = this[i];
                if (result.Invalid)
                {
                    continue;
                }
                if (callback(result.Key))
                {
                    RemoveVerifiedKey(i);
                    if (rangeAdvance)
                    {
                        RangeAdvance(i);
                    }
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// textual representation of the cache state
        /// </summary>
        public string Artwork
        {
            get
            {
                Tuple<int, int> range = SearchRange;
                List<int> positives = Cache.Keys.Where(k => k > offset && k < range.Item2 + 1).ToList();
                StringBuilder sb = new StringBuilder();
                sb.Append("[ ");
                for (int i = offset + 1; i < range.Item2 + 1; i++)
                {
                    sb.Append(positives.Contains(i) ? "|" : ".");
                }
                sb.Append(" ]");
                return sb.ToString();
            }
        }

        public override string ToString()
        {
            return Artwork;
        }
    }
}
